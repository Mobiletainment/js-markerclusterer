{"version":3,"file":"index.umd.js","sources":["../node_modules/core-js/internals/global.js","../node_modules/core-js/internals/engine-v8-version.js","../node_modules/core-js/internals/fails.js","../node_modules/core-js/internals/descriptors.js","../node_modules/core-js/internals/object-property-is-enumerable.js","../node_modules/core-js/internals/create-property-descriptor.js","../node_modules/core-js/internals/classof-raw.js","../node_modules/core-js/internals/indexed-object.js","../node_modules/core-js/internals/require-object-coercible.js","../node_modules/core-js/internals/to-indexed-object.js","../node_modules/core-js/internals/is-callable.js","../node_modules/core-js/internals/is-object.js","../node_modules/core-js/internals/get-built-in.js","../node_modules/core-js/internals/engine-user-agent.js","../node_modules/core-js/internals/native-symbol.js","../node_modules/core-js/internals/use-symbol-as-uid.js","../node_modules/core-js/internals/is-symbol.js","../node_modules/core-js/internals/a-callable.js","../node_modules/core-js/internals/try-to-string.js","../node_modules/core-js/internals/set-global.js","../node_modules/core-js/internals/shared-store.js","../node_modules/core-js/internals/shared.js","../node_modules/core-js/internals/to-object.js","../node_modules/core-js/internals/has.js","../node_modules/core-js/internals/uid.js","../node_modules/core-js/internals/well-known-symbol.js","../node_modules/core-js/internals/to-primitive.js","../node_modules/core-js/internals/get-method.js","../node_modules/core-js/internals/ordinary-to-primitive.js","../node_modules/core-js/internals/to-property-key.js","../node_modules/core-js/internals/document-create-element.js","../node_modules/core-js/internals/ie8-dom-define.js","../node_modules/core-js/internals/object-get-own-property-descriptor.js","../node_modules/core-js/internals/an-object.js","../node_modules/core-js/internals/object-define-property.js","../node_modules/core-js/internals/create-non-enumerable-property.js","../node_modules/core-js/internals/inspect-source.js","../node_modules/core-js/internals/internal-state.js","../node_modules/core-js/internals/native-weak-map.js","../node_modules/core-js/internals/shared-key.js","../node_modules/core-js/internals/hidden-keys.js","../node_modules/core-js/internals/function-name.js","../node_modules/core-js/internals/redefine.js","../node_modules/core-js/internals/to-integer.js","../node_modules/core-js/internals/to-length.js","../node_modules/core-js/internals/to-absolute-index.js","../node_modules/core-js/internals/array-includes.js","../node_modules/core-js/internals/object-keys-internal.js","../node_modules/core-js/internals/enum-bug-keys.js","../node_modules/core-js/internals/object-get-own-property-names.js","../node_modules/core-js/internals/object-get-own-property-symbols.js","../node_modules/core-js/internals/own-keys.js","../node_modules/core-js/internals/copy-constructor-properties.js","../node_modules/core-js/internals/is-forced.js","../node_modules/core-js/internals/export.js","../node_modules/core-js/internals/is-array.js","../node_modules/core-js/internals/to-string-tag-support.js","../node_modules/core-js/internals/classof.js","../node_modules/core-js/internals/is-constructor.js","../node_modules/core-js/internals/array-species-constructor.js","../node_modules/core-js/internals/array-species-create.js","../node_modules/core-js/internals/array-iteration.js","../node_modules/core-js/internals/function-bind-context.js","../node_modules/core-js/internals/array-method-has-species-support.js","../node_modules/core-js/modules/es.array.map.js","../node_modules/core-js/internals/array-reduce.js","../node_modules/core-js/internals/array-method-is-strict.js","../node_modules/core-js/internals/engine-is-node.js","../node_modules/core-js/modules/es.array.reduce.js","../node_modules/core-js/modules/es.array.filter.js","../src/cluster.ts","../src/algorithms/utils.ts","../src/algorithms/core.ts","../node_modules/core-js/internals/dom-iterables.js","../node_modules/core-js/internals/dom-token-list-prototype.js","../node_modules/core-js/internals/array-for-each.js","../node_modules/core-js/modules/web.dom-collections.for-each.js","../node_modules/core-js/modules/web.url.to-json.js","../src/algorithms/grid.ts","../src/algorithms/noop.ts","../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/clone/dist/es/index.js","../node_modules/@turf/meta/dist/es/index.js","../node_modules/skmeans/dist/node/distance.js","../node_modules/skmeans/dist/node/kinit.js","../node_modules/skmeans/dist/node/main.js","../src/algorithms/kmeans.ts","../node_modules/@turf/clusters-kmeans/dist/es/index.js","../node_modules/core-js/internals/object-keys.js","../node_modules/core-js/internals/object-assign.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/distance/dist/es/index.js","../node_modules/core-js/modules/es.object.assign.js","../node_modules/density-clustering/lib/DBSCAN.js","../node_modules/density-clustering/lib/KMEANS.js","../node_modules/density-clustering/lib/PriorityQueue.js","../node_modules/density-clustering/lib/OPTICS.js","../node_modules/density-clustering/lib/index.js","../src/algorithms/dbscan.ts","../node_modules/@turf/clusters-dbscan/dist/es/index.js","../node_modules/kdbush/src/sort.js","../node_modules/kdbush/src/within.js","../node_modules/kdbush/src/index.js","../node_modules/kdbush/src/range.js","../node_modules/supercluster/index.js","../node_modules/fast-deep-equal/es6/index.js","../src/algorithms/supercluster.ts","../node_modules/core-js/modules/es.array.index-of.js","../node_modules/core-js/internals/create-property.js","../node_modules/core-js/modules/es.array.splice.js","../node_modules/core-js/internals/a-possible-prototype.js","../node_modules/core-js/internals/object-create.js","../node_modules/core-js/internals/object-set-prototype-of.js","../node_modules/core-js/internals/inherit-if-required.js","../node_modules/core-js/internals/object-define-properties.js","../node_modules/core-js/internals/html.js","../node_modules/core-js/internals/string-trim.js","../node_modules/core-js/internals/to-string.js","../node_modules/core-js/modules/es.number.constructor.js","../src/renderer.ts","../src/markerclusterer.ts","../src/overlay-view-safe.ts"],"sourcesContent":["var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n","var global = require('../internals/global');\nvar userAgent = require('../internals/engine-user-agent');\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  version = match[0] < 4 ? 1 : match[0] + match[1];\n} else if (userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = match[1];\n  }\n}\n\nmodule.exports = version && +version;\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n","var fails = require('../internals/fails');\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n","'use strict';\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","var fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\n\nvar split = ''.split;\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n","// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n","// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n","// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nmodule.exports = function (argument) {\n  return typeof argument === 'function';\n};\n","var isCallable = require('../internals/is-callable');\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : isCallable(it);\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n","/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = require('../internals/engine-v8-version');\nvar fails = require('../internals/fails');\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n","/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n","var isCallable = require('../internals/is-callable');\nvar getBuiltIn = require('../internals/get-built-in');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && Object(it) instanceof $Symbol;\n};\n","var isCallable = require('../internals/is-callable');\nvar tryToString = require('../internals/try-to-string');\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw TypeError(tryToString(argument) + ' is not a function');\n};\n","module.exports = function (argument) {\n  try {\n    return String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n","var global = require('../internals/global');\n\nmodule.exports = function (key, value) {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n","var global = require('../internals/global');\nvar setGlobal = require('../internals/set-global');\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n","var IS_PURE = require('../internals/is-pure');\nvar store = require('../internals/shared-store');\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.18.1',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'\n});\n","var requireObjectCoercible = require('../internals/require-object-coercible');\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n","var toObject = require('../internals/to-object');\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty.call(toObject(it), key);\n};\n","var id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n","var global = require('../internals/global');\nvar shared = require('../internals/shared');\nvar has = require('../internals/has');\nvar uid = require('../internals/uid');\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    if (NATIVE_SYMBOL && has(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n","var isObject = require('../internals/is-object');\nvar isSymbol = require('../internals/is-symbol');\nvar getMethod = require('../internals/get-method');\nvar ordinaryToPrimitive = require('../internals/ordinary-to-primitive');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = exoticToPrim.call(input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n","var aCallable = require('../internals/a-callable');\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable(func);\n};\n","var isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = fn.call(input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var toPrimitive = require('../internals/to-primitive');\nvar isSymbol = require('../internals/is-symbol');\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : String(key);\n};\n","var global = require('../internals/global');\nvar isObject = require('../internals/is-object');\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar createElement = require('../internals/document-create-element');\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n","var DESCRIPTORS = require('../internals/descriptors');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPropertyKey = require('../internals/to-property-key');\nvar has = require('../internals/has');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n","var isObject = require('../internals/is-object');\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw TypeError(String(argument) + ' is not an object');\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar anObject = require('../internals/an-object');\nvar toPropertyKey = require('../internals/to-property-key');\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var isCallable = require('../internals/is-callable');\nvar store = require('../internals/shared-store');\n\nvar functionToString = Function.toString;\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString.call(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n","var NATIVE_WEAK_MAP = require('../internals/native-weak-map');\nvar global = require('../internals/global');\nvar isObject = require('../internals/is-object');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar objectHas = require('../internals/has');\nvar shared = require('../internals/shared-store');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar inspectSource = require('../internals/inspect-source');\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));\n","var shared = require('../internals/shared');\nvar uid = require('../internals/uid');\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n","module.exports = {};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar has = require('../internals/has');\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = has(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n","var global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\nvar has = require('../internals/has');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar setGlobal = require('../internals/set-global');\nvar inspectSource = require('../internals/inspect-source');\nvar InternalStateModule = require('../internals/internal-state');\nvar CONFIGURABLE_FUNCTION_NAME = require('../internals/function-name').CONFIGURABLE;\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  var name = options && options.name !== undefined ? options.name : key;\n  var state;\n  if (isCallable(value)) {\n    if (String(name).slice(0, 7) === 'Symbol(') {\n      name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n    }\n    if (!has(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n      createNonEnumerableProperty(value, 'name', name);\n    }\n    state = enforceInternalState(value);\n    if (!state.source) {\n      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n    }\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n});\n","var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.es/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n","var toInteger = require('../internals/to-integer');\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n","var toInteger = require('../internals/to-integer');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n","var toIndexedObject = require('../internals/to-indexed-object');\nvar toLength = require('../internals/to-length');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n","var has = require('../internals/has');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar indexOf = require('../internals/array-includes').indexOf;\nvar hiddenKeys = require('../internals/hidden-keys');\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n","var getBuiltIn = require('../internals/get-built-in');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n","var has = require('../internals/has');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n","var global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar redefine = require('../internals/redefine');\nvar setGlobal = require('../internals/set-global');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n  options.name        - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n","var classof = require('../internals/classof-raw');\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(argument) {\n  return classof(argument) == 'Array';\n};\n","var wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n","var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');\nvar isCallable = require('../internals/is-callable');\nvar classofRaw = require('../internals/classof-raw');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n","var fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\nvar classof = require('../internals/classof');\nvar getBuiltIn = require('../internals/get-built-in');\nvar inspectSource = require('../internals/inspect-source');\n\nvar empty = [];\nvar construct = getBuiltIn('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = constructorRegExp.exec;\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(function () { /* empty */ });\n\nvar isConstructorModern = function (argument) {\n  if (!isCallable(argument)) return false;\n  try {\n    construct(Object, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function (argument) {\n  if (!isCallable(argument)) return false;\n  switch (classof(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n    // we can't check .prototype since constructors produced by .bind haven't it\n  } return INCORRECT_TO_STRING || !!exec.call(constructorRegExp, inspectSource(argument));\n};\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nmodule.exports = !construct || fails(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n","var isArray = require('../internals/is-array');\nvar isConstructor = require('../internals/is-constructor');\nvar isObject = require('../internals/is-object');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar SPECIES = wellKnownSymbol('species');\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor(C) && (C === Array || isArray(C.prototype))) C = undefined;\n    else if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n","var arraySpeciesConstructor = require('../internals/array-species-constructor');\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\n","var bind = require('../internals/function-bind-context');\nvar IndexedObject = require('../internals/indexed-object');\nvar toObject = require('../internals/to-object');\nvar toLength = require('../internals/to-length');\nvar arraySpeciesCreate = require('../internals/array-species-create');\n\nvar push = [].push;\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push.call(target, value); // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push.call(target, value); // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod(7)\n};\n","var aCallable = require('../internals/a-callable');\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aCallable(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","var fails = require('../internals/fails');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\nvar V8_VERSION = require('../internals/engine-v8-version');\n\nvar SPECIES = wellKnownSymbol('species');\n\nmodule.exports = function (METHOD_NAME) {\n  // We can't use this feature detection in V8 since it causes\n  // deoptimization and serious performance degradation\n  // https://github.com/zloirock/core-js/issues/677\n  return V8_VERSION >= 51 || !fails(function () {\n    var array = [];\n    var constructor = array.constructor = {};\n    constructor[SPECIES] = function () {\n      return { foo: 1 };\n    };\n    return array[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar $map = require('../internals/array-iteration').map;\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');\n\n// `Array.prototype.map` method\n// https://tc39.es/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","var aCallable = require('../internals/a-callable');\nvar toObject = require('../internals/to-object');\nvar IndexedObject = require('../internals/indexed-object');\nvar toLength = require('../internals/to-length');\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aCallable(callbackfn);\n    var O = toObject(that);\n    var self = IndexedObject(O);\n    var length = toLength(O.length);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw TypeError('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod(true)\n};\n","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing\n    method.call(null, argument || function () { throw 1; }, 1);\n  });\n};\n","var classof = require('../internals/classof-raw');\nvar global = require('../internals/global');\n\nmodule.exports = classof(global.process) == 'process';\n","'use strict';\nvar $ = require('../internals/export');\nvar $reduce = require('../internals/array-reduce').left;\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\nvar CHROME_VERSION = require('../internals/engine-v8-version');\nvar IS_NODE = require('../internals/engine-is-node');\n\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar $filter = require('../internals/array-iteration').filter;\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');\n\n// `Array.prototype.filter` method\n// https://tc39.es/ecma262/#sec-array.prototype.filter\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ClusterOptions {\n  position?: google.maps.LatLng | google.maps.LatLngLiteral;\n  markers?: google.maps.Marker[];\n}\n\nexport class Cluster {\n  public marker: google.maps.Marker;\n  public readonly markers?: google.maps.Marker[];\n  protected _position: google.maps.LatLng;\n\n  constructor({ markers, position }: ClusterOptions) {\n    this.markers = markers;\n\n    if (position) {\n      if (position instanceof google.maps.LatLng) {\n        this._position = position;\n      } else {\n        this._position = new google.maps.LatLng(position);\n      }\n    }\n  }\n\n  public get bounds(): google.maps.LatLngBounds | undefined {\n    if (this.markers.length === 0 && !this._position) {\n      return undefined;\n    }\n\n    return this.markers.reduce((bounds, marker) => {\n      return bounds.extend(marker.getPosition());\n    }, new google.maps.LatLngBounds(this._position, this._position));\n  }\n\n  public get position(): google.maps.LatLng {\n    return this._position || this.bounds.getCenter();\n  }\n\n  /**\n   * Get the count of **visible** markers.\n   */\n  public get count(): number {\n    return this.markers.filter((m: google.maps.Marker) => m.getVisible())\n      .length;\n  }\n\n  /**\n   * Add a marker to the cluster.\n   */\n  public push(marker: google.maps.Marker): void {\n    this.markers.push(marker);\n  }\n\n  /**\n   * Cleanup references and remove marker from map.\n   */\n  public delete(): void {\n    if (this.marker) {\n      this.marker.setMap(null);\n      delete this.marker;\n    }\n    this.markers.length = 0;\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const filterMarkersToPaddedViewport = (\n  map: google.maps.Map,\n  mapCanvasProjection: google.maps.MapCanvasProjection,\n  markers: google.maps.Marker[],\n  viewportPadding: number\n): google.maps.Marker[] => {\n  const extendedMapBounds = extendBoundsToPaddedViewport(\n    map.getBounds(),\n    mapCanvasProjection,\n    viewportPadding\n  );\n  return markers.filter((marker) =>\n    extendedMapBounds.contains(marker.getPosition())\n  );\n};\n\n/**\n * Extends a bounds by a number of pixels in each direction.\n */\nexport const extendBoundsToPaddedViewport = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection,\n  pixels: number\n): google.maps.LatLngBounds => {\n  const { northEast, southWest } = latLngBoundsToPixelBounds(\n    bounds,\n    projection\n  );\n  const extendedPixelBounds = extendPixelBounds(\n    { northEast, southWest },\n    pixels\n  );\n  return pixelBoundsToLatLngBounds(extendedPixelBounds, projection);\n};\n\n/**\n * @hidden\n */\nexport const distanceBetweenPoints = (\n  p1: google.maps.LatLngLiteral,\n  p2: google.maps.LatLngLiteral\n): number => {\n  const R = 6371; // Radius of the Earth in km\n  const dLat = ((p2.lat - p1.lat) * Math.PI) / 180;\n  const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos((p1.lat * Math.PI) / 180) *\n      Math.cos((p2.lat * Math.PI) / 180) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n};\n\ntype PixelBounds = {\n  northEast: google.maps.Point;\n  southWest: google.maps.Point;\n};\n\n/**\n * @hidden\n */\nconst latLngBoundsToPixelBounds = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection\n): PixelBounds => {\n  return {\n    northEast: projection.fromLatLngToDivPixel(bounds.getNorthEast()),\n    southWest: projection.fromLatLngToDivPixel(bounds.getSouthWest()),\n  };\n};\n\n/**\n * @hidden\n */\nexport const extendPixelBounds = (\n  { northEast, southWest }: PixelBounds,\n  pixels: number\n): PixelBounds => {\n  northEast.x += pixels;\n  northEast.y -= pixels;\n\n  southWest.x -= pixels;\n  southWest.y += pixels;\n\n  return { northEast, southWest };\n};\n\n/**\n * @hidden\n */\nexport const pixelBoundsToLatLngBounds = (\n  { northEast, southWest }: PixelBounds,\n  projection: google.maps.MapCanvasProjection\n): google.maps.LatLngBounds => {\n  const bounds = new google.maps.LatLngBounds();\n  bounds.extend(projection.fromDivPixelToLatLng(northEast));\n  bounds.extend(projection.fromDivPixelToLatLng(southWest));\n  return bounds;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"../cluster\";\nimport { filterMarkersToPaddedViewport } from \"./utils\";\n\nexport interface AlgorithmInput {\n  /**\n   * The map containing the markers and clusters.\n   */\n  map: google.maps.Map;\n  /**\n   * An array of markers to be clustered.\n   *\n   * There are some specific edge cases to be aware of including the following:\n   * * Markers that are not visible.\n   */\n  markers: google.maps.Marker[];\n  /**\n   * The `mapCanvasProjection` enables easy conversion from lat/lng to pixel.\n   *\n   * @see [MapCanvasProjection](https://developers.google.com/maps/documentation/javascript/reference/overlay-view#MapCanvasProjection)\n   */\n  mapCanvasProjection: google.maps.MapCanvasProjection;\n}\n\nexport interface Algorithm {\n  /**\n   * Calculates an array of {@link Cluster}.\n   */\n  calculate: ({ markers, map }: AlgorithmInput) => Cluster[];\n}\n\nexport interface AlgorithmOptions {\n  maxZoom?: number;\n}\n/**\n * @hidden\n */\nexport abstract class AbstractAlgorithm implements Algorithm {\n  protected maxZoom: number;\n\n  constructor({ maxZoom = 16 }: AlgorithmOptions) {\n    this.maxZoom = maxZoom;\n  }\n  /**\n   * Helper function to bypass clustering based upon some map state such as\n   * zoom, number of markers, etc.\n   *\n   * ```typescript\n   *  cluster({markers, map}: AlgorithmInput): Cluster[] {\n   *    if (shouldBypassClustering(map)) {\n   *      return this.noop({markers, map})\n   *    }\n   * }\n   * ```\n   */\n  protected noop({ markers }: AlgorithmInput): Cluster[] {\n    return noop(markers);\n  }\n  /**\n   * Calculates an array of {@link Cluster}. Calculate is separate from\n   * {@link cluster} as it does preprocessing on the markers such as filtering\n   * based upon the viewport as in {@link AbstractViewportAlgorithm}. Caching\n   * and other optimizations can also be done here.\n   */\n  public abstract calculate({ markers, map }: AlgorithmInput): Cluster[];\n\n  /**\n   * Clusters the markers and called from {@link calculate}.\n   */\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport interface ViewportAlgorithmOptions extends AlgorithmOptions {\n  /**\n   * The number of pixels to extend beyond the viewport bounds when filtering\n   * markers prior to clustering.\n   */\n  viewportPadding?: number;\n}\n\n/**\n * Abstract viewport algorithm proves a class to filter markers by a padded\n * viewport. This is a common optimization.\n *\n * @hidden\n */\nexport abstract class AbstractViewportAlgorithm extends AbstractAlgorithm {\n  protected viewportPadding = 60;\n\n  constructor({ viewportPadding = 60, ...options }: ViewportAlgorithmOptions) {\n    super(options);\n    this.viewportPadding = viewportPadding;\n  }\n  public calculate({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    if (map.getZoom() >= this.maxZoom) {\n      return this.noop({\n        markers,\n        map,\n        mapCanvasProjection,\n      });\n    }\n\n    return this.cluster({\n      markers: filterMarkersToPaddedViewport(\n        map,\n        mapCanvasProjection,\n        markers,\n        this.viewportPadding\n      ),\n      map,\n      mapCanvasProjection,\n    });\n  }\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport const noop = (markers: google.maps.Marker[]): Cluster[] => {\n  const clusters = markers.map(\n    (marker) =>\n      new Cluster({\n        position: marker.getPosition(),\n        markers: [marker],\n      })\n  );\n  return clusters;\n};\n","// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nmodule.exports = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n","// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = require('../internals/document-create-element');\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;\n\nmodule.exports = DOMTokenListPrototype === Object.prototype ? undefined : DOMTokenListPrototype;\n","'use strict';\nvar $forEach = require('../internals/array-iteration').forEach;\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\n\nvar STRICT_METHOD = arrayMethodIsStrict('forEach');\n\n// `Array.prototype.forEach` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.foreach\nmodule.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {\n  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n// eslint-disable-next-line es/no-array-prototype-foreach -- safe\n} : [].forEach;\n","var global = require('../internals/global');\nvar DOMIterables = require('../internals/dom-iterables');\nvar DOMTokenListPrototype = require('../internals/dom-token-list-prototype');\nvar forEach = require('../internals/array-for-each');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\n\nvar handlePrototype = function (CollectionPrototype) {\n  // some Chrome versions have non-configurable methods on DOMTokenList\n  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {\n    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);\n  } catch (error) {\n    CollectionPrototype.forEach = forEach;\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  if (DOMIterables[COLLECTION_NAME]) {\n    handlePrototype(global[COLLECTION_NAME] && global[COLLECTION_NAME].prototype);\n  }\n}\n\nhandlePrototype(DOMTokenListPrototype);\n","'use strict';\nvar $ = require('../internals/export');\n\n// `URL.prototype.toJSON` method\n// https://url.spec.whatwg.org/#dom-url-tojson\n$({ target: 'URL', proto: true, enumerable: true }, {\n  toJSON: function toJSON() {\n    return URL.prototype.toString.call(this);\n  }\n});\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { distanceBetweenPoints, extendBoundsToPaddedViewport } from \"./utils\";\n\nimport { Cluster } from \"../cluster\";\n\nexport interface GridOptions extends ViewportAlgorithmOptions {\n  gridSize?: number;\n  /**\n   * Max distance between cluster center and point in meters.\n   * @default 10000\n   */\n  maxDistance?: number;\n}\n\n/**\n * The default Grid algorithm historically used in Google Maps marker clustering.\n */\nexport class GridAlgorithm extends AbstractViewportAlgorithm {\n  protected gridSize: number;\n  protected maxDistance: number;\n  protected clusters: Cluster[] = [];\n\n  constructor({ maxDistance = 40000, gridSize = 40, ...options }: GridOptions) {\n    super(options);\n\n    this.maxDistance = maxDistance;\n    this.gridSize = gridSize;\n  }\n\n  protected cluster({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    this.clusters = [];\n    markers.forEach((marker) => {\n      this.addToClosestCluster(marker, map, mapCanvasProjection);\n    });\n\n    return this.clusters;\n  }\n\n  protected addToClosestCluster(\n    marker: google.maps.Marker,\n    map: google.maps.Map,\n    projection: google.maps.MapCanvasProjection\n  ): void {\n    let maxDistance = this.maxDistance; // Some large number\n    let cluster: Cluster = null;\n\n    for (let i = 0; i < this.clusters.length; i++) {\n      const candidate = this.clusters[i];\n      const distance = distanceBetweenPoints(\n        candidate.bounds.getCenter().toJSON(),\n        marker.getPosition().toJSON()\n      );\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        cluster = candidate;\n      }\n    }\n\n    if (\n      cluster &&\n      extendBoundsToPaddedViewport(\n        cluster.bounds,\n        projection,\n        this.gridSize\n      ).contains(marker.getPosition())\n    ) {\n      cluster.push(marker);\n    } else {\n      const cluster = new Cluster({ markers: [marker] });\n      this.clusters.push(cluster);\n    }\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AbstractAlgorithm, AlgorithmInput, AlgorithmOptions } from \"./core\";\n\nimport { Cluster } from \"../cluster\";\n\n/**\n * Noop algorithm does not generate any clusters or filter markers by the an extended viewport.\n */\nexport class NoopAlgorithm extends AbstractAlgorithm {\n  constructor({ ...options }: AlgorithmOptions) {\n    super(options);\n  }\n  public calculate({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    return this.cluster({ markers, map, mapCanvasProjection });\n  }\n\n  protected cluster(input: AlgorithmInput): Cluster[] {\n    return this.noop(input);\n  }\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","\"use strict\";\n\nmodule.exports = {\n\t/**\n  * Euclidean distance\n  */\n\teudist: function eudist(v1, v2, sqrt) {\n\t\tvar len = v1.length;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar d = (v1[i] || 0) - (v2[i] || 0);\n\t\t\tsum += d * d;\n\t\t}\n\t\t// Square root not really needed\n\t\treturn sqrt ? Math.sqrt(sum) : sum;\n\t},\n\tmandist: function mandist(v1, v2, sqrt) {\n\t\tvar len = v1.length;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tsum += Math.abs((v1[i] || 0) - (v2[i] || 0));\n\t\t}\n\n\t\t// Square root not really needed\n\t\treturn sqrt ? Math.sqrt(sum) : sum;\n\t},\n\n\n\t/**\n  * Unidimensional distance\n  */\n\tdist: function dist(v1, v2, sqrt) {\n\t\tvar d = Math.abs(v1 - v2);\n\t\treturn sqrt ? d : d * d;\n\t}\n};\n//# sourceMappingURL=distance.js.map\n","\"use strict\";\n\nvar Distance = require(\"./distance.js\"),\n    eudist = Distance.eudist,\n    dist = Distance.dist;\n\nmodule.exports = {\n\tkmrand: function kmrand(data, k) {\n\t\tvar map = {},\n\t\t    ks = [],\n\t\t    t = k << 2;\n\t\tvar len = data.length;\n\t\tvar multi = data[0].length > 0;\n\n\t\twhile (ks.length < k && t-- > 0) {\n\t\t\tvar d = data[Math.floor(Math.random() * len)];\n\t\t\tvar key = multi ? d.join(\"_\") : \"\" + d;\n\t\t\tif (!map[key]) {\n\t\t\t\tmap[key] = true;\n\t\t\t\tks.push(d);\n\t\t\t}\n\t\t}\n\n\t\tif (ks.length < k) throw new Error(\"Error initializating clusters\");else return ks;\n\t},\n\n\n\t/**\n  * K-means++ initial centroid selection\n  */\n\tkmpp: function kmpp(data, k) {\n\t\tvar distance = data[0].length ? eudist : dist;\n\t\tvar ks = [],\n\t\t    len = data.length;\n\t\tvar multi = data[0].length > 0;\n\t\tvar map = {};\n\n\t\t// First random centroid\n\t\tvar c = data[Math.floor(Math.random() * len)];\n\t\tvar key = multi ? c.join(\"_\") : \"\" + c;\n\t\tks.push(c);\n\t\tmap[key] = true;\n\n\t\t// Retrieve next centroids\n\t\twhile (ks.length < k) {\n\t\t\t// Min Distances between current centroids and data points\n\t\t\tvar dists = [],\n\t\t\t    lk = ks.length;\n\t\t\tvar dsum = 0,\n\t\t\t    prs = [];\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar min = Infinity;\n\t\t\t\tfor (var j = 0; j < lk; j++) {\n\t\t\t\t\tvar _dist = distance(data[i], ks[j]);\n\t\t\t\t\tif (_dist <= min) min = _dist;\n\t\t\t\t}\n\t\t\t\tdists[i] = min;\n\t\t\t}\n\n\t\t\t// Sum all min distances\n\t\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\t\tdsum += dists[_i];\n\t\t\t}\n\n\t\t\t// Probabilities and cummulative prob (cumsum)\n\t\t\tfor (var _i2 = 0; _i2 < len; _i2++) {\n\t\t\t\tprs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };\n\t\t\t}\n\n\t\t\t// Sort Probabilities\n\t\t\tprs.sort(function (a, b) {\n\t\t\t\treturn a.pr - b.pr;\n\t\t\t});\n\n\t\t\t// Cummulative Probabilities\n\t\t\tprs[0].cs = prs[0].pr;\n\t\t\tfor (var _i3 = 1; _i3 < len; _i3++) {\n\t\t\t\tprs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;\n\t\t\t}\n\n\t\t\t// Randomize\n\t\t\tvar rnd = Math.random();\n\n\t\t\t// Gets only the items whose cumsum >= rnd\n\t\t\tvar idx = 0;\n\t\t\twhile (idx < len - 1 && prs[idx++].cs < rnd) {}\n\t\t\tks.push(prs[idx - 1].v);\n\t\t\t/*\n   let done = false;\n   while(!done) {\n   \t// this is our new centroid\n   \tc = prs[idx-1].v\n   \tkey = multi? c.join(\"_\") : `${c}`;\n   \tif(!map[key]) {\n   \t\tmap[key] = true;\n   \t\tks.push(c);\n   \t\tdone = true;\n   \t}\n   \telse {\n   \t\tidx++;\n   \t}\n   }\n   */\n\t\t}\n\n\t\treturn ks;\n\t}\n};\n//# sourceMappingURL=kinit.js.map\n","\"use strict\";\n\n/*jshint esversion: 6 */\n\nvar Distance = require(\"./distance.js\"),\n    ClusterInit = require(\"./kinit.js\"),\n    eudist = Distance.eudist,\n    mandist = Distance.mandist,\n    dist = Distance.dist,\n    kmrand = ClusterInit.kmrand,\n    kmpp = ClusterInit.kmpp;\n\nvar MAX = 10000;\n\n/**\n * Inits an array with values\n */\nfunction init(len, val, v) {\n\tv = v || [];\n\tfor (var i = 0; i < len; i++) {\n\t\tv[i] = val;\n\t}return v;\n}\n\nfunction skmeans(data, k, initial, maxit) {\n\tvar ks = [],\n\t    old = [],\n\t    idxs = [],\n\t    dist = [];\n\tvar conv = false,\n\t    it = maxit || MAX;\n\tvar len = data.length,\n\t    vlen = data[0].length,\n\t    multi = vlen > 0;\n\tvar count = [];\n\n\tif (!initial) {\n\t\tvar _idxs = {};\n\t\twhile (ks.length < k) {\n\t\t\tvar idx = Math.floor(Math.random() * len);\n\t\t\tif (!_idxs[idx]) {\n\t\t\t\t_idxs[idx] = true;\n\t\t\t\tks.push(data[idx]);\n\t\t\t}\n\t\t}\n\t} else if (initial == \"kmrand\") {\n\t\tks = kmrand(data, k);\n\t} else if (initial == \"kmpp\") {\n\t\tks = kmpp(data, k);\n\t} else {\n\t\tks = initial;\n\t}\n\n\tdo {\n\t\t// Reset k count\n\t\tinit(k, 0, count);\n\n\t\t// For each value in data, find the nearest centroid\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar min = Infinity,\n\t\t\t    _idx = 0;\n\t\t\tfor (var j = 0; j < k; j++) {\n\t\t\t\t// Multidimensional or unidimensional\n\t\t\t\tvar dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);\n\t\t\t\tif (dist <= min) {\n\t\t\t\t\tmin = dist;\n\t\t\t\t\t_idx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidxs[i] = _idx; // Index of the selected centroid for that value\n\t\t\tcount[_idx]++; // Number of values for this centroid\n\t\t}\n\n\t\t// Recalculate centroids\n\t\tvar sum = [],\n\t\t    old = [],\n\t\t    dif = 0;\n\t\tfor (var _j = 0; _j < k; _j++) {\n\t\t\t// Multidimensional or unidimensional\n\t\t\tsum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;\n\t\t\told[_j] = ks[_j];\n\t\t}\n\n\t\t// If multidimensional\n\t\tif (multi) {\n\t\t\tfor (var _j2 = 0; _j2 < k; _j2++) {\n\t\t\t\tks[_j2] = [];\n\t\t\t} // Sum values and count for each centroid\n\t\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\t\tvar _idx2 = idxs[_i],\n\t\t\t\t    // Centroid for that item\n\t\t\t\tvsum = sum[_idx2],\n\t\t\t\t    // Sum values for this centroid\n\t\t\t\tvect = data[_i]; // Current vector\n\n\t\t\t\t// Accumulate value on the centroid for current vector\n\t\t\t\tfor (var h = 0; h < vlen; h++) {\n\t\t\t\t\tvsum[h] += vect[h];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Calculate the average for each centroid\n\t\t\tconv = true;\n\t\t\tfor (var _j3 = 0; _j3 < k; _j3++) {\n\t\t\t\tvar ksj = ks[_j3],\n\t\t\t\t    // Current centroid\n\t\t\t\tsumj = sum[_j3],\n\t\t\t\t    // Accumulated centroid values\n\t\t\t\toldj = old[_j3],\n\t\t\t\t    // Old centroid value\n\t\t\t\tcj = count[_j3]; // Number of elements for this centroid\n\n\t\t\t\t// New average\n\t\t\t\tfor (var _h = 0; _h < vlen; _h++) {\n\t\t\t\t\tksj[_h] = sumj[_h] / cj || 0; // New centroid\n\t\t\t\t}\n\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tif (conv) {\n\t\t\t\t\tfor (var _h2 = 0; _h2 < vlen; _h2++) {\n\t\t\t\t\t\tif (oldj[_h2] != ksj[_h2]) {\n\t\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If unidimensional\n\t\telse {\n\t\t\t\t// Sum values and count for each centroid\n\t\t\t\tfor (var _i2 = 0; _i2 < len; _i2++) {\n\t\t\t\t\tvar _idx3 = idxs[_i2];\n\t\t\t\t\tsum[_idx3] += data[_i2];\n\t\t\t\t}\n\t\t\t\t// Calculate the average for each centroid\n\t\t\t\tfor (var _j4 = 0; _j4 < k; _j4++) {\n\t\t\t\t\tks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid\n\t\t\t\t}\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tconv = true;\n\t\t\t\tfor (var _j5 = 0; _j5 < k; _j5++) {\n\t\t\t\t\tif (old[_j5] != ks[_j5]) {\n\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tconv = conv || --it <= 0;\n\t} while (!conv);\n\n\treturn {\n\t\tit: MAX - it,\n\t\tk: k,\n\t\tidxs: idxs,\n\t\tcentroids: ks\n\t};\n}\n\nmodule.exports = skmeans;\n//# sourceMappingURL=main.js.map\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { featureCollection, point } from \"@turf/helpers\";\n\nimport { Cluster } from \"../cluster\";\nimport clustersKmeans from \"@turf/clusters-kmeans\";\n\nexport interface KmeansAlgorithmOptions extends ViewportAlgorithmOptions {\n  numberOfClusters: number | ((count: number, zoom: number) => number);\n}\n\n/**\n * Experimental algorithm using Kmeans.\n *\n * @see https://www.npmjs.com/package/@turf/clusters-kmeans\n */\nexport class KmeansAlgorithm extends AbstractViewportAlgorithm {\n  protected numberOfClusters:\n    | number\n    | ((count: number, zoom: number) => number);\n\n  constructor({ numberOfClusters, ...options }: KmeansAlgorithmOptions) {\n    super(options);\n    this.numberOfClusters = numberOfClusters;\n  }\n\n  protected cluster({ markers, map }: AlgorithmInput): Cluster[] {\n    const clusters: Cluster[] = [];\n\n    if (markers.length === 0) {\n      return clusters;\n    }\n    const points = featureCollection(\n      markers.map((marker) => {\n        return point([marker.getPosition().lng(), marker.getPosition().lat()]);\n      })\n    );\n\n    let numberOfClusters: number;\n\n    if (this.numberOfClusters instanceof Function) {\n      numberOfClusters = this.numberOfClusters(markers.length, map.getZoom());\n    } else {\n      numberOfClusters = this.numberOfClusters;\n    }\n    clustersKmeans(points, { numberOfClusters }).features.forEach(\n      (point, i) => {\n        if (!clusters[point.properties.cluster]) {\n          clusters[point.properties.cluster] = new Cluster({\n            position: {\n              lng: point.properties.centroid[0],\n              lat: point.properties.centroid[1],\n            },\n            markers: [],\n          });\n        }\n\n        clusters[point.properties.cluster].push(markers[i]);\n      }\n    );\n\n    return clusters;\n  }\n}\n","import clone from \"@turf/clone\";\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport skmeans from \"skmeans\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .\n * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)\n *\n * @name clustersKmeans\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var options = {numberOfClusters: 7};\n * var clustered = turf.clustersKmeans(points, options);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersKmeans(points, options) {\n    if (options === void 0) { options = {}; }\n    // Default Params\n    var count = points.features.length;\n    options.numberOfClusters =\n        options.numberOfClusters || Math.round(Math.sqrt(count / 2));\n    // numberOfClusters can't be greater than the number of points\n    // fallbacks to count\n    if (options.numberOfClusters > count)\n        options.numberOfClusters = count;\n    // Clone points to prevent any mutations (enabled by default)\n    if (options.mutate !== true)\n        points = clone(points);\n    // collect points coordinates\n    var data = coordAll(points);\n    // create seed to avoid skmeans to drift\n    var initialCentroids = data.slice(0, options.numberOfClusters);\n    // create skmeans clusters\n    var skmeansResult = skmeans(data, options.numberOfClusters, initialCentroids);\n    // store centroids {clusterId: [number, number]}\n    var centroids = {};\n    skmeansResult.centroids.forEach(function (coord, idx) {\n        centroids[idx] = coord;\n    });\n    // add associated cluster number\n    featureEach(points, function (point, index) {\n        var clusterId = skmeansResult.idxs[index];\n        point.properties.cluster = clusterId;\n        point.properties.centroid = centroids[clusterId];\n    });\n    return points;\n}\nexport default clustersKmeans;\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar objectKeys = require('../internals/object-keys');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar toObject = require('../internals/to-object');\nvar IndexedObject = require('../internals/indexed-object');\n\n// eslint-disable-next-line es/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nmodule.exports = !$assign || fails(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians, } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n","var $ = require('../internals/export');\nvar assign = require('../internals/object-assign');\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es/no-object-assign -- required for testing\n$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {\n  assign: assign\n});\n","/**\r\n * DBSCAN - Density based clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * DBSCAN class construcotr\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {DBSCAN}\r\n */\r\nfunction DBSCAN(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {Array} */\r\n  this.dataset = [];\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 2;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n  /** @type {Array} */\r\n  this.clusters = [];\r\n  /** @type {Array} */\r\n  this.noise = [];\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._visited = [];\r\n  /** @type {Array} */\r\n  this._assigned = [];\r\n  /** @type {number} */\r\n  this._datasetLength = 0;\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n};\r\n\r\n/******************************************************************************/\r\n// public functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nDBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0; pointId < this._datasetLength; pointId++) {\r\n    // if point is not visited, check if it forms a cluster\r\n    if (this._visited[pointId] !== 1) {\r\n      this._visited[pointId] = 1;\r\n\r\n      // if closest neighborhood is too small to form a cluster, mark as noise\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      if (neighbors.length < this.minPts) {\r\n        this.noise.push(pointId);\r\n      } else {\r\n        // create new cluster and add point\r\n        var clusterId = this.clusters.length;\r\n        this.clusters.push([]);\r\n        this._addToCluster(pointId, clusterId);\r\n\r\n        this._expandCluster(clusterId, neighbors);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this.noise = [];\r\n\r\n    this._datasetLength = dataset.length;\r\n    this._visited = new Array(this._datasetLength);\r\n    this._assigned = new Array(this._datasetLength);\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Expand cluster to closest points of given neighborhood\r\n *\r\n * @param {number} clusterId\r\n * @param {Array} neighbors\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._expandCluster = function(clusterId, neighbors) {\r\n\r\n  /**\r\n   * It's very important to calculate length of neighbors array each time,\r\n   * as the number of elements changes over time\r\n   */\r\n  for (var i = 0; i < neighbors.length; i++) {\r\n    var pointId2 = neighbors[i];\r\n\r\n    if (this._visited[pointId2] !== 1) {\r\n      this._visited[pointId2] = 1;\r\n      var neighbors2 = this._regionQuery(pointId2);\r\n\r\n      if (neighbors2.length >= this.minPts) {\r\n        neighbors = this._mergeArrays(neighbors, neighbors2);\r\n      }\r\n    }\r\n\r\n    // add to cluster\r\n    if (this._assigned[pointId2] !== 1) {\r\n      this._addToCluster(pointId2, clusterId);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Add new point to cluster\r\n *\r\n * @param {number} pointId\r\n * @param {number} clusterId\r\n */\r\nDBSCAN.prototype._addToCluster = function(pointId, clusterId) {\r\n  this.clusters[clusterId].push(pointId);\r\n  this._assigned[pointId] = 1;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId,\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._regionQuery = function(pointId) {\r\n  var neighbors = [];\r\n\r\n  for (var id = 0; id < this._datasetLength; id++) {\r\n    var dist = this.distance(this.dataset[pointId], this.dataset[id]);\r\n    if (dist < this.epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * @param {Array} a\r\n * @param {Array} b\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._mergeArrays = function(a, b) {\r\n  var len = b.length;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    var P = b[i];\r\n    if (a.indexOf(P) < 0) {\r\n      a.push(P);\r\n    }\r\n  }\r\n\r\n  return a;\r\n};\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = DBSCAN;\r\n}\r\n","﻿/**\r\n * KMEANS clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * KMEANS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} k - number of clusters\r\n * @param {function} distance - distance function\r\n * @returns {KMEANS}\r\n */\r\n function KMEANS(dataset, k, distance) {\r\n  this.k = 3; // number of clusters\r\n  this.dataset = []; // set of feature vectors\r\n  this.assignments = []; // set of associated clusters for each feature vector\r\n  this.centroids = []; // vectors for our clusters\r\n\r\n  this.init(dataset, k, distance);\r\n}\r\n\r\n/**\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.init = function(dataset, k, distance) {\r\n  this.assignments = [];\r\n  this.centroids = [];\r\n\r\n  if (typeof dataset !== 'undefined') {\r\n    this.dataset = dataset;\r\n  }\r\n\r\n  if (typeof k !== 'undefined') {\r\n    this.k = k;\r\n  }\r\n\r\n  if (typeof distance !== 'undefined') {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.run = function(dataset, k) {\r\n  this.init(dataset, k);\r\n\r\n  var len = this.dataset.length;\r\n\r\n  // initialize centroids\r\n  for (var i = 0; i < this.k; i++) {\r\n    this.centroids[i] = this.randomCentroid();\r\n\t}\r\n\r\n  var change = true;\r\n  while(change) {\r\n\r\n    // assign feature vectors to clusters\r\n    change = this.assign();\r\n\r\n    // adjust location of centroids\r\n    for (var centroidId = 0; centroidId < this.k; centroidId++) {\r\n      var mean = new Array(maxDim);\r\n      var count = 0;\r\n\r\n      // init mean vector\r\n      for (var dim = 0; dim < maxDim; dim++) {\r\n        mean[dim] = 0;\r\n      }\r\n\r\n      for (var j = 0; j < len; j++) {\r\n        var maxDim = this.dataset[j].length;\r\n\r\n        // if current cluster id is assigned to point\r\n        if (centroidId === this.assignments[j]) {\r\n          for (var dim = 0; dim < maxDim; dim++) {\r\n            mean[dim] += this.dataset[j][dim];\r\n          }\r\n          count++;\r\n        }\r\n      }\r\n\r\n      if (count > 0) {\r\n        // if cluster contain points, adjust centroid position\r\n        for (var dim = 0; dim < maxDim; dim++) {\r\n          mean[dim] /= count;\r\n        }\r\n        this.centroids[centroidId] = mean;\r\n      } else {\r\n        // if cluster is empty, generate new random centroid\r\n        this.centroids[centroidId] = this.randomCentroid();\r\n        change = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.getClusters();\r\n};\r\n\r\n/**\r\n * Generate random centroid\r\n *\r\n * @returns {Array}\r\n */\r\nKMEANS.prototype.randomCentroid = function() {\r\n  var maxId = this.dataset.length -1;\r\n  var centroid;\r\n  var id;\r\n\r\n  do {\r\n    id = Math.round(Math.random() * maxId);\r\n    centroid = this.dataset[id];\r\n  } while (this.centroids.indexOf(centroid) >= 0);\r\n\r\n  return centroid;\r\n}\r\n\r\n/**\r\n * Assign points to clusters\r\n *\r\n * @returns {boolean}\r\n */\r\nKMEANS.prototype.assign = function() {\r\n  var change = false;\r\n  var len = this.dataset.length;\r\n  var closestCentroid;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);\r\n\r\n    if (closestCentroid != this.assignments[i]) {\r\n      this.assignments[i] = closestCentroid;\r\n      change = true;\r\n    }\r\n  }\r\n\r\n  return change;\r\n}\r\n\r\n/**\r\n * Extract information about clusters\r\n *\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.getClusters = function() {\r\n  var clusters = new Array(this.k);\r\n  var centroidId;\r\n\r\n  for (var pointId = 0; pointId < this.assignments.length; pointId++) {\r\n    centroidId = this.assignments[pointId];\r\n\r\n    // init empty cluster\r\n    if (typeof clusters[centroidId] === 'undefined') {\r\n      clusters[centroidId] = [];\r\n    }\r\n\r\n    clusters[centroidId].push(pointId);\r\n  }\r\n\r\n  return clusters;\r\n};\r\n\r\n// utils\r\n\r\n/**\r\n * @params {Array} point\r\n * @params {Array.<Array>} set\r\n * @params {Function} f\r\n * @returns {number}\r\n */\r\nKMEANS.prototype.argmin = function(point, set, f) {\r\n  var min = Number.MAX_VALUE;\r\n  var arg = 0;\r\n  var len = set.length;\r\n  var d;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    d = f(point, set[i]);\r\n    if (d < min) {\r\n      min = d;\r\n      arg = i;\r\n    }\r\n  }\r\n\r\n  return arg;\r\n};\r\n\r\n/**\r\n * Euclidean distance\r\n *\r\n * @params {number} p\r\n * @params {number} q\r\n * @returns {number}\r\n */\r\nKMEANS.prototype.distance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    var diff = p[i] - q[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = KMEANS;\r\n}\r\n","/**\r\n * PriorityQueue\r\n * Elements in this queue are sorted according to their value\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * PriorityQueue class construcotr\r\n * @constructor\r\n *\r\n * @example\r\n * queue: [1,2,3,4]\r\n * priorities: [4,1,2,3]\r\n * > result = [1,4,2,3]\r\n *\r\n * @param {Array} elements\r\n * @param {Array} priorities\r\n * @param {string} sorting - asc / desc\r\n * @returns {PriorityQueue}\r\n */\r\nfunction PriorityQueue(elements, priorities, sorting) {\r\n  /** @type {Array} */\r\n  this._queue = [];\r\n  /** @type {Array} */\r\n  this._priorities = [];\r\n  /** @type {string} */\r\n  this._sorting = 'desc';\r\n\r\n  this._init(elements, priorities, sorting);\r\n};\r\n\r\n/**\r\n * Insert element\r\n *\r\n * @param {Object} ele\r\n * @param {Object} priority\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.insert = function(ele, priority) {\r\n  var indexToInsert = this._queue.length;\r\n  var index = indexToInsert;\r\n\r\n  while (index--) {\r\n    var priority2 = this._priorities[index];\r\n    if (this._sorting === 'desc') {\r\n      if (priority > priority2) {\r\n        indexToInsert = index;\r\n      }\r\n    } else {\r\n      if (priority < priority2) {\r\n        indexToInsert = index;\r\n      }\r\n    }\r\n  }\r\n\r\n  this._insertAt(ele, priority, indexToInsert);\r\n};\r\n\r\n/**\r\n * Remove element\r\n *\r\n * @param {Object} ele\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.remove = function(ele) {\r\n  var index = this._queue.length;\r\n\r\n  while (index--) {\r\n    var ele2 = this._queue[index];\r\n    if (ele === ele2) {\r\n      this._queue.splice(index, 1);\r\n      this._priorities.splice(index, 1);\r\n      break;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * For each loop wrapper\r\n *\r\n * @param {function} func\r\n * @returs {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.forEach = function(func) {\r\n  this._queue.forEach(func);\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElements = function() {\r\n  return this._queue;\r\n};\r\n\r\n/**\r\n * @param {number} index\r\n * @returns {Object}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElementPriority = function(index) {\r\n  return this._priorities[index];\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getPriorities = function() {\r\n  return this._priorities;\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElementsWithPriorities = function() {\r\n  var result = [];\r\n\r\n  for (var i = 0, l = this._queue.length; i < l; i++) {\r\n    result.push([this._queue[i], this._priorities[i]]);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} elements\r\n * @param {Array} priorities\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nPriorityQueue.prototype._init = function(elements, priorities, sorting) {\r\n\r\n  if (elements && priorities) {\r\n    this._queue = [];\r\n    this._priorities = [];\r\n\r\n    if (elements.length !== priorities.length) {\r\n      throw new Error('Arrays must have the same length');\r\n    }\r\n\r\n    for (var i = 0; i < elements.length; i++) {\r\n      this.insert(elements[i], priorities[i]);\r\n    }\r\n  }\r\n\r\n  if (sorting) {\r\n    this._sorting = sorting;\r\n  }\r\n};\r\n\r\n/**\r\n * Insert element at given position\r\n *\r\n * @param {Object} ele\r\n * @param {number} index\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nPriorityQueue.prototype._insertAt = function(ele, priority, index) {\r\n  if (this._queue.length === index) {\r\n    this._queue.push(ele);\r\n    this._priorities.push(priority);\r\n  } else {\r\n    this._queue.splice(index, 0, ele);\r\n    this._priorities.splice(index, 0, priority);\r\n  }\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = PriorityQueue;\r\n}\r\n","\r\n/**\r\n * @requires ./PriorityQueue.js\r\n */\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n      var PriorityQueue = require('./PriorityQueue.js');\r\n}\r\n\r\n/**\r\n * OPTICS - Ordering points to identify the clustering structure\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * OPTICS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {OPTICS}\r\n */\r\nfunction OPTICS(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 1;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._reachability = [];\r\n  /** @type {Array} */\r\n  this._processed = [];\r\n  /** @type {number} */\r\n  this._coreDistance = 0;\r\n  /** @type {Array} */\r\n  this._orderedList = [];\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n}\r\n\r\n/******************************************************************************/\r\n// pulic functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nOPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {\r\n    if (this._processed[pointId] !== 1) {\r\n      this._processed[pointId] = 1;\r\n      this.clusters.push([pointId]);\r\n      var clusterId = this.clusters.length - 1;\r\n\r\n      this._orderedList.push(pointId);\r\n      var priorityQueue = new PriorityQueue(null, null, 'asc');\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      // using priority queue assign elements to new cluster\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, priorityQueue);\r\n        this._expandCluster(clusterId, priorityQueue);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/**\r\n * Generate reachability plot for all points\r\n *\r\n * @returns {array}\r\n * @access public\r\n */\r\nOPTICS.prototype.getReachabilityPlot = function() {\r\n  var reachabilityPlot = [];\r\n\r\n  for (var i = 0, l = this._orderedList.length; i < l; i++) {\r\n    var pointId = this._orderedList[i];\r\n    var distance = this._reachability[pointId];\r\n\r\n    reachabilityPlot.push([pointId, distance]);\r\n  }\r\n\r\n  return reachabilityPlot;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this._reachability = new Array(this.dataset.length);\r\n    this._processed = new Array(this.dataset.length);\r\n    this._coreDistance = 0;\r\n    this._orderedList = [];\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Update information in queue\r\n *\r\n * @param {number} pointId\r\n * @param {Array} neighbors\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {\r\n  var self = this;\r\n\r\n  this._coreDistance = this._distanceToCore(pointId);\r\n  neighbors.forEach(function(pointId2) {\r\n    if (self._processed[pointId2] === undefined) {\r\n      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);\r\n      var newReachableDistance = Math.max(self._coreDistance, dist);\r\n\r\n      if (self._reachability[pointId2] === undefined) {\r\n        self._reachability[pointId2] = newReachableDistance;\r\n        queue.insert(pointId2, newReachableDistance);\r\n      } else {\r\n        if (newReachableDistance < self._reachability[pointId2]) {\r\n          self._reachability[pointId2] = newReachableDistance;\r\n          queue.remove(pointId2);\r\n          queue.insert(pointId2, newReachableDistance);\r\n        }\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Expand cluster\r\n *\r\n * @param {number} clusterId\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._expandCluster = function(clusterId, queue) {\r\n  var queueElements = queue.getElements();\r\n\r\n  for (var p = 0, l = queueElements.length; p < l; p++) {\r\n    var pointId = queueElements[p];\r\n    if (this._processed[pointId] === undefined) {\r\n      var neighbors = this._regionQuery(pointId);\r\n      this._processed[pointId] = 1;\r\n\r\n      this.clusters[clusterId].push(pointId);\r\n      this._orderedList.push(pointId);\r\n\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, queue);\r\n        this._expandCluster(clusterId, queue);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Calculating distance to cluster core\r\n *\r\n * @param {number} pointId\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._distanceToCore = function(pointId) {\r\n  var l = this.epsilon;\r\n  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {\r\n    var neighbors = this._regionQuery(pointId, coreDistCand);\r\n    if (neighbors.length >= this.minPts) {\r\n      return coreDistCand;\r\n    }\r\n  }\r\n\r\n  return;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nOPTICS.prototype._regionQuery = function(pointId, epsilon) {\r\n  epsilon = epsilon || this.epsilon;\r\n  var neighbors = [];\r\n\r\n  for (var id = 0, l = this.dataset.length; id < l; id++) {\r\n    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = OPTICS;\r\n}\r\n","\r\nif (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = {\r\n      DBSCAN: require('./DBSCAN.js'),\r\n      KMEANS: require('./KMEANS.js'),\r\n      OPTICS: require('./OPTICS.js'),\r\n      PriorityQueue: require('./PriorityQueue.js')\r\n    };\r\n}\r\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { Units, featureCollection, point } from \"@turf/helpers\";\n\nimport { Cluster } from \"../cluster\";\nimport clustersDbscan from \"@turf/clusters-dbscan\";\n\nexport interface DBScanOptions {\n  units?: Units;\n  minPoints?: number;\n  mutate?: boolean;\n}\n\nexport interface DBScanAlgorithmOptions extends ViewportAlgorithmOptions {\n  maxDistance?: number;\n  minPoints?: number;\n}\n\nconst DEFAULT_INTERNAL_DBSCAN_OPTION: DBScanOptions = {\n  units: \"kilometers\",\n  mutate: false,\n  minPoints: 1,\n};\n\n/**\n *\n * **This algorithm is not yet ready for use!**\n *\n * Experimental algorithm using DBScan.\n *\n * @see https://www.npmjs.com/package/@turf/clusters-dbscan\n */\nexport class DBScanAlgorithm extends AbstractViewportAlgorithm {\n  protected maxDistance: number;\n  protected options: DBScanOptions;\n  constructor({\n    maxDistance = 200,\n    minPoints = DEFAULT_INTERNAL_DBSCAN_OPTION.minPoints,\n    ...options\n  }: DBScanAlgorithmOptions) {\n    super(options);\n    this.maxDistance = maxDistance;\n    this.options = {\n      ...DEFAULT_INTERNAL_DBSCAN_OPTION,\n      minPoints,\n    };\n  }\n\n  protected cluster({\n    markers,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    const points = featureCollection(\n      markers.map((marker) => {\n        const projectedPoint = mapCanvasProjection.fromLatLngToContainerPixel(\n          marker.getPosition()\n        );\n        return point([projectedPoint.x, projectedPoint.y]);\n      })\n    );\n\n    const grouped: google.maps.Marker[][] = [];\n\n    clustersDbscan(points, this.maxDistance, this.options).features.forEach(\n      (point, i) => {\n        if (!grouped[point.properties.cluster]) {\n          grouped[point.properties.cluster] = [];\n        }\n\n        grouped[point.properties.cluster].push(markers[i]);\n      }\n    );\n\n    return grouped.map((markers) => new Cluster({ markers }));\n  }\n}\n","import clone from \"@turf/clone\";\nimport distance from \"@turf/distance\";\nimport { coordAll } from \"@turf/meta\";\nimport { convertLength, } from \"@turf/helpers\";\nimport clustering from \"density-clustering\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters according to {@link DBSCAN's|https://en.wikipedia.org/wiki/DBSCAN} data clustering algorithm.\n *\n * @name clustersDbscan\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers only)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] in which `maxDistance` is expressed, can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated\n * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,\n * points which do not meet this requirement will be classified as an 'edge' or 'noise'.\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var maxDistance = 100;\n * var clustered = turf.clustersDbscan(points, maxDistance);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersDbscan(points, maxDistance, options) {\n    // Input validation being handled by Typescript\n    // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');\n    // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');\n    // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');\n    // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');\n    if (options === void 0) { options = {}; }\n    // Clone points to prevent any mutations\n    if (options.mutate !== true)\n        points = clone(points);\n    // Defaults\n    options.minPoints = options.minPoints || 3;\n    // create clustered ids\n    var dbscan = new clustering.DBSCAN();\n    var clusteredIds = dbscan.run(coordAll(points), convertLength(maxDistance, options.units), options.minPoints, distance);\n    // Tag points to Clusters ID\n    var clusterId = -1;\n    clusteredIds.forEach(function (clusterIds) {\n        clusterId++;\n        // assign cluster ids to input points\n        clusterIds.forEach(function (idx) {\n            var clusterPoint = points.features[idx];\n            if (!clusterPoint.properties)\n                clusterPoint.properties = {};\n            clusterPoint.properties.cluster = clusterId;\n            clusterPoint.properties.dbscan = \"core\";\n        });\n    });\n    // handle noise points, if any\n    // edges points are tagged by DBSCAN as both 'noise' and 'cluster' as they can \"reach\" less than 'minPoints' number of points\n    dbscan.noise.forEach(function (noiseId) {\n        var noisePoint = points.features[noiseId];\n        if (!noisePoint.properties)\n            noisePoint.properties = {};\n        if (noisePoint.properties.cluster)\n            noisePoint.properties.dbscan = \"edge\";\n        else\n            noisePoint.properties.dbscan = \"noise\";\n    });\n    return points;\n}\nexport default clustersDbscan;\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            if (numPoints >= minPoints) { // enough points to form a cluster\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n  var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AbstractAlgorithm, AlgorithmInput } from \"./core\";\nimport SuperCluster, { ClusterFeature } from \"supercluster\";\n\nimport { Cluster } from \"../cluster\";\nimport equal from \"fast-deep-equal/es6\";\n\nexport type SuperClusterOptions = SuperCluster.Options<\n  { [name: string]: any },\n  { [name: string]: any }\n>;\n\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nexport class SuperClusterAlgorithm extends AbstractAlgorithm {\n  protected superCluster: SuperCluster;\n  protected markers: google.maps.Marker[];\n  constructor({ maxZoom, radius = 60, ...options }: SuperClusterOptions) {\n    super({ maxZoom });\n\n    this.superCluster = new SuperCluster({\n      maxZoom: this.maxZoom,\n      radius,\n      ...options,\n    });\n  }\n  public calculate(input: AlgorithmInput): Cluster[] {\n    if (!equal(input.markers, this.markers)) {\n      this.markers = input.markers;\n\n      const points = this.markers.map((marker) => {\n        return {\n          type: \"Feature\" as const,\n          geometry: {\n            type: \"Point\" as const,\n            coordinates: [\n              marker.getPosition().lng(),\n              marker.getPosition().lat(),\n            ],\n          },\n          properties: { marker },\n        };\n      });\n\n      this.superCluster.load(points);\n    }\n    return this.cluster(input);\n  }\n\n  public cluster({ map }: AlgorithmInput): Cluster[] {\n    const { west, south, east, north } = map.getBounds().toJSON();\n    return this.superCluster\n      .getClusters([west, south, east, north], map.getZoom())\n      .map(this.transformCluster.bind(this));\n  }\n\n  protected transformCluster({\n    geometry: {\n      coordinates: [lng, lat],\n    },\n    properties,\n  }: ClusterFeature<{ marker: google.maps.Marker }>): Cluster {\n    if (properties.cluster) {\n      return new Cluster({\n        markers: this.superCluster\n          .getLeaves(properties.cluster_id, Infinity)\n          .map((leaf) => leaf.properties.marker),\n        position: new google.maps.LatLng({ lat, lng }),\n      });\n    } else {\n      const marker = properties.marker;\n\n      return new Cluster({\n        markers: [marker],\n        position: marker.getPosition(),\n      });\n    }\n  }\n}\n","'use strict';\n/* eslint-disable es/no-array-prototype-indexof -- required for testing */\nvar $ = require('../internals/export');\nvar $indexOf = require('../internals/array-includes').indexOf;\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\n\nvar nativeIndexOf = [].indexOf;\n\nvar NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;\nvar STRICT_METHOD = arrayMethodIsStrict('indexOf');\n\n// `Array.prototype.indexOf` method\n// https://tc39.es/ecma262/#sec-array.prototype.indexof\n$({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {\n  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? nativeIndexOf.apply(this, arguments) || 0\n      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","'use strict';\nvar toPropertyKey = require('../internals/to-property-key');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPropertyKey(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar toInteger = require('../internals/to-integer');\nvar toLength = require('../internals/to-length');\nvar toObject = require('../internals/to-object');\nvar arraySpeciesCreate = require('../internals/array-species-create');\nvar createProperty = require('../internals/create-property');\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');\n\nvar max = Math.max;\nvar min = Math.min;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';\n\n// `Array.prototype.splice` method\n// https://tc39.es/ecma262/#sec-array.prototype.splice\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  splice: function splice(start, deleteCount /* , ...items */) {\n    var O = toObject(this);\n    var len = toLength(O.length);\n    var actualStart = toAbsoluteIndex(start, len);\n    var argumentsLength = arguments.length;\n    var insertCount, actualDeleteCount, A, k, from, to;\n    if (argumentsLength === 0) {\n      insertCount = actualDeleteCount = 0;\n    } else if (argumentsLength === 1) {\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n    } else {\n      insertCount = argumentsLength - 2;\n      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);\n    }\n    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {\n      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);\n    }\n    A = arraySpeciesCreate(O, actualDeleteCount);\n    for (k = 0; k < actualDeleteCount; k++) {\n      from = actualStart + k;\n      if (from in O) createProperty(A, k, O[from]);\n    }\n    A.length = actualDeleteCount;\n    if (insertCount < actualDeleteCount) {\n      for (k = actualStart; k < len - actualDeleteCount; k++) {\n        from = k + actualDeleteCount;\n        to = k + insertCount;\n        if (from in O) O[to] = O[from];\n        else delete O[to];\n      }\n      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];\n    } else if (insertCount > actualDeleteCount) {\n      for (k = len - actualDeleteCount; k > actualStart; k--) {\n        from = k + actualDeleteCount - 1;\n        to = k + insertCount - 1;\n        if (from in O) O[to] = O[from];\n        else delete O[to];\n      }\n    }\n    for (k = 0; k < insertCount; k++) {\n      O[k + actualStart] = arguments[k + 2];\n    }\n    O.length = len - actualDeleteCount + insertCount;\n    return A;\n  }\n});\n","var isCallable = require('../internals/is-callable');\n\nmodule.exports = function (argument) {\n  if (typeof argument === 'object' || isCallable(argument)) return argument;\n  throw TypeError(\"Can't set \" + String(argument) + ' as a prototype');\n};\n","/* global ActiveXObject -- old IE, WSH */\nvar anObject = require('../internals/an-object');\nvar defineProperties = require('../internals/object-define-properties');\nvar enumBugKeys = require('../internals/enum-bug-keys');\nvar hiddenKeys = require('../internals/hidden-keys');\nvar html = require('../internals/html');\nvar documentCreateElement = require('../internals/document-create-element');\nvar sharedKey = require('../internals/shared-key');\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n","/* eslint-disable no-proto -- safe */\nvar anObject = require('../internals/an-object');\nvar aPossiblePrototype = require('../internals/a-possible-prototype');\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n    setter.call(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter.call(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n","var isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\n\n// makes subclassing work correct for wrapped built-ins\nmodule.exports = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    isCallable(NewTarget = dummy.constructor) &&\n    NewTarget !== Wrapper &&\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf($this, NewTargetPrototype);\n  return $this;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar anObject = require('../internals/an-object');\nvar objectKeys = require('../internals/object-keys');\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);\n  return O;\n};\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n","var requireObjectCoercible = require('../internals/require-object-coercible');\nvar toString = require('../internals/to-string');\nvar whitespaces = require('../internals/whitespaces');\n\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod = function (TYPE) {\n  return function ($this) {\n    var string = toString(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod(3)\n};\n","var classof = require('../internals/classof');\n\nmodule.exports = function (argument) {\n  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return String(argument);\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar global = require('../internals/global');\nvar isForced = require('../internals/is-forced');\nvar redefine = require('../internals/redefine');\nvar has = require('../internals/has');\nvar classof = require('../internals/classof-raw');\nvar inheritIfRequired = require('../internals/inherit-if-required');\nvar isSymbol = require('../internals/is-symbol');\nvar toPrimitive = require('../internals/to-primitive');\nvar fails = require('../internals/fails');\nvar create = require('../internals/object-create');\nvar getOwnPropertyNames = require('../internals/object-get-own-property-names').f;\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar defineProperty = require('../internals/object-define-property').f;\nvar trim = require('../internals/string-trim').trim;\n\nvar NUMBER = 'Number';\nvar NativeNumber = global[NUMBER];\nvar NumberPrototype = NativeNumber.prototype;\n\n// Opera ~12 has broken Object#toString\nvar BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;\n\n// `ToNumber` abstract operation\n// https://tc39.es/ecma262/#sec-tonumber\nvar toNumber = function (argument) {\n  if (isSymbol(argument)) throw TypeError('Cannot convert a Symbol value to a number');\n  var it = toPrimitive(argument, 'number');\n  var first, third, radix, maxCode, digits, length, index, code;\n  if (typeof it == 'string' && it.length > 2) {\n    it = trim(it);\n    first = it.charCodeAt(0);\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i\n        default: return +it;\n      }\n      digits = it.slice(2);\n      length = digits.length;\n      for (index = 0; index < length; index++) {\n        code = digits.charCodeAt(index);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\n// `Number` constructor\n// https://tc39.es/ecma262/#sec-number-constructor\nif (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {\n  var NumberWrapper = function Number(value) {\n    var it = arguments.length < 1 ? 0 : value;\n    var dummy = this;\n    return dummy instanceof NumberWrapper\n      // check on 1..constructor(foo) case\n      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)\n        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);\n  };\n  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES2015 (in case, if modules with ES2015 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,' +\n    // ESNext\n    'fromString,range'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {\n      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));\n    }\n  }\n  NumberWrapper.prototype = NumberPrototype;\n  NumberPrototype.constructor = NumberWrapper;\n  redefine(global, NUMBER, NumberWrapper);\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"./cluster\";\n\n/**\n * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.\n */\nexport class ClusterStats {\n  public readonly markers: { sum: number };\n  public readonly clusters: {\n    count: number;\n    markers: {\n      mean: number;\n      sum: number;\n      min: number;\n      max: number;\n    };\n  };\n\n  constructor(markers: google.maps.Marker[], clusters: Cluster[]) {\n    this.markers = { sum: markers.length };\n\n    const clusterMarkerCounts = clusters.map((a) => a.count);\n    const clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);\n\n    this.clusters = {\n      count: clusters.length,\n      markers: {\n        mean: clusterMarkerSum / clusters.length,\n        sum: clusterMarkerSum,\n        min: Math.min(...clusterMarkerCounts),\n        max: Math.max(...clusterMarkerCounts),\n      },\n    };\n  }\n}\n\nexport interface Renderer {\n  /**\n   * Turn a {@link Cluster} into a `google.maps.Marker`.\n   *\n   * Below is a simple example to create a marker with the number of markers in the cluster as a label.\n   *\n   * ```typescript\n   * return new google.maps.Marker({\n   *   position,\n   *   label: String(markers.length),\n   * });\n   * ```\n   */\n  render(cluster: Cluster, stats: ClusterStats): google.maps.Marker;\n}\n\nexport class DefaultRenderer implements Renderer {\n  /**\n   * The default render function for the library used by {@link MarkerClusterer}.\n   *\n   * Currently set to use the following:\n   *\n   * ```typescript\n   * // change color if this cluster has more markers than the mean cluster\n   * const color =\n   *   count > Math.max(10, stats.clusters.markers.mean)\n   *     ? \"#ff0000\"\n   *     : \"#0000ff\";\n   *\n   * // create svg url with fill color\n   * const svg = window.btoa(`\n   * <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n   * </svg>`);\n   *\n   * // create marker using svg icon\n   * return new google.maps.Marker({\n   *   position,\n   *   icon: {\n   *     url: `data:image/svg+xml;base64,${svg}`,\n   *     scaledSize: new google.maps.Size(45, 45),\n   *   },\n   *   label: {\n   *     text: String(count),\n   *     color: \"rgba(255,255,255,0.9)\",\n   *     fontSize: \"12px\",\n   *   },\n   *   // adjust zIndex to be above other markers\n   *   zIndex: 1000 + count,\n   * });\n   * ```\n   */\n  public render(\n    { count, position }: Cluster,\n    stats: ClusterStats\n  ): google.maps.Marker {\n    // change color if this cluster has more markers than the mean cluster\n    const color =\n      count > Math.max(10, stats.clusters.markers.mean) ? \"#ff0000\" : \"#0000ff\";\n\n    // create svg url with fill color\n    const svg = window.btoa(`\n  <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n    <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n  </svg>`);\n\n    // create marker using svg icon\n    return new google.maps.Marker({\n      position,\n      icon: {\n        url: `data:image/svg+xml;base64,${svg}`,\n        scaledSize: new google.maps.Size(45, 45),\n      },\n      label: {\n        text: String(count),\n        color: \"rgba(255,255,255,0.9)\",\n        fontSize: \"12px\",\n      },\n      // adjust zIndex to be above other markers\n      zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,\n    });\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Algorithm, SuperClusterAlgorithm } from \"./algorithms\";\nimport { ClusterStats, DefaultRenderer, Renderer } from \"./renderer\";\n\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\nexport type onClusterClickHandler = (\n  event: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n) => void;\nexport interface MarkerClustererOptions {\n  markers?: google.maps.Marker[];\n  /**\n   * An algorithm to cluster markers. Default is {@link SuperClusterAlgorithm}. Must\n   * provide a `calculate` method accepting {@link AlgorithmInput} and returning\n   * an array of {@link Cluster}.\n   */\n  algorithm?: Algorithm;\n  map?: google.maps.Map | null;\n  /**\n   * An object that converts a {@link Cluster} into a `google.maps.Marker`.\n   * Default is {@link DefaultRenderer}.\n   */\n  renderer?: Renderer;\n  onClusterClick?: onClusterClickHandler;\n}\n\nexport enum MarkerClustererEvents {\n  CLUSTERING_BEGIN = \"clusteringbegin\",\n  CLUSTERING_END = \"clusteringend\",\n  CLUSTER_CLICK = \"click\",\n}\n\nexport const defaultOnClusterClickHandler: onClusterClickHandler = (\n  _: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n): void => {\n  map.fitBounds(cluster.bounds);\n};\n/**\n * MarkerClusterer creates and manages per-zoom-level clusters for large amounts\n * of markers. See {@link MarkerClustererOptions} for more details.\n *\n * <iframe src=\"https://googlemaps.github.io/js-three/public/anchor/index.html\"></iframe>\n */\nexport class MarkerClusterer extends OverlayViewSafe {\n  /** @see {@link MarkerClustererOptions.onClusterClick} */\n  public onClusterClick: onClusterClickHandler;\n  /** @see {@link MarkerClustererOptions.algorithm} */\n  protected algorithm: Algorithm;\n  protected clusters: Cluster[];\n  protected markers: google.maps.Marker[];\n  /** @see {@link MarkerClustererOptions.renderer} */\n  protected renderer: Renderer;\n  /** @see {@link MarkerClustererOptions.map} */\n  protected map: google.maps.Map | null;\n  /** @see {@link MarkerClustererOptions.maxZoom} */\n  protected idleListener: google.maps.MapsEventListener;\n\n  constructor({\n    map,\n    markers = [],\n    algorithm = new SuperClusterAlgorithm({}),\n    renderer = new DefaultRenderer(),\n    onClusterClick = defaultOnClusterClickHandler,\n  }: MarkerClustererOptions) {\n    super();\n    this.markers = markers;\n    this.clusters = [];\n\n    this.algorithm = algorithm;\n    this.renderer = renderer;\n\n    this.onClusterClick = onClusterClick;\n\n    if (map) {\n      this.setMap(map);\n    }\n  }\n\n  public addMarker(marker: google.maps.Marker, noDraw?: boolean): void {\n    this.markers.push(marker);\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public addMarkers(markers: google.maps.Marker[], noDraw?: boolean): void {\n    markers.forEach((marker) => {\n      this.addMarker(marker, true);\n    });\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public removeMarker(marker: google.maps.Marker, noDraw?: boolean): boolean {\n    const index = this.markers.indexOf(marker);\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n\n    marker.setMap(null);\n    this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n\n    if (!noDraw) {\n      this.render();\n    }\n\n    return true;\n  }\n\n  public removeMarkers(\n    markers: google.maps.Marker[],\n    noDraw?: boolean\n  ): boolean {\n    let removed = false;\n\n    markers.forEach((marker) => {\n      removed = removed || this.removeMarker(marker, true);\n    });\n\n    if (removed && !noDraw) {\n      this.render();\n    }\n\n    return removed;\n  }\n\n  public clearMarkers(noDraw?: boolean): void {\n    this.markers.forEach((marker) => this.removeMarker(marker, true));\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  /**\n   * Recalculates and draws all the marker clusters.\n   */\n  public render(): void {\n    const map = this.getMap();\n    if (map instanceof google.maps.Map && this.getProjection()) {\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_BEGIN,\n        this\n      );\n      const clusters = this.algorithm.calculate({\n        markers: this.markers,\n        map,\n        mapCanvasProjection: this.getProjection(),\n      });\n\n      // reset visibility of markers and clusters\n      this.reset();\n\n      // store new clusters\n      this.clusters = clusters;\n\n      this.renderClusters();\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_END,\n        this\n      );\n    }\n  }\n\n  public onAdd(): void {\n    this.idleListener = this.getMap().addListener(\n      \"idle\",\n      this.render.bind(this)\n    );\n    this.render();\n  }\n\n  public onRemove(): void {\n    google.maps.event.removeListener(this.idleListener);\n    this.reset();\n  }\n\n  protected reset(): void {\n    this.markers.forEach((marker) => marker.setMap(null));\n    this.markers.forEach((marker) => marker.setMap(null));\n    this.clusters.forEach((cluster) => cluster.delete());\n    this.clusters = [];\n  }\n\n  protected renderClusters(): void {\n    // generate stats to pass to renderers\n    const stats = new ClusterStats(this.markers, this.clusters);\n    const map = this.getMap() as google.maps.Map;\n\n    this.clusters.forEach((cluster) => {\n      if (cluster.markers.length === 1) {\n        cluster.marker = cluster.markers[0];\n      } else {\n        cluster.marker = this.renderer.render(cluster, stats);\n\n        if (this.onClusterClick) {\n          cluster.marker.addListener(\n            \"click\",\n            /* istanbul ignore next */\n            (event: google.maps.MapMouseEvent) => {\n              google.maps.event.trigger(\n                this,\n                MarkerClustererEvents.CLUSTER_CLICK,\n                cluster\n              );\n              this.onClusterClick(event, cluster, map);\n            }\n          );\n        }\n      }\n\n      cluster.marker.setMap(map);\n    });\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OverlayViewSafe extends google.maps.OverlayView {}\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1: any, type2: any): void {\n  /* istanbul ignore next */\n  // eslint-disable-next-line prefer-const\n  for (let property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n\n/**\n * @ignore\n */\nexport class OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n}\n"],"names":["match","version","check","it","Math","globalThis","window","self","global","this","Function","exec","error","fails","Object","defineProperty","get","$propertyIsEnumerable","propertyIsEnumerable","getOwnPropertyDescriptor","call","V","descriptor","enumerable","bitmap","value","configurable","writable","toString","slice","split","classof","undefined","TypeError","IndexedObject","requireObjectCoercible","argument","isCallable","aFunction","namespace","method","arguments","length","getBuiltIn","process","Deno","versions","v8","userAgent","getOwnPropertySymbols","symbol","Symbol","String","sham","V8_VERSION","NATIVE_SYMBOL","iterator","USE_SYMBOL_AS_UID","$Symbol","tryToString","key","SHARED","setGlobal","module","store","push","mode","copyright","hasOwnProperty","hasOwn","toObject","id","postfix","random","WellKnownSymbolsStore","shared","createWellKnownSymbol","withoutSetter","uid","name","has","TO_PRIMITIVE","wellKnownSymbol","input","pref","isObject","isSymbol","func","result","exoticToPrim","aCallable","fn","val","valueOf","ordinaryToPrimitive","toPrimitive","document","EXISTS","createElement","DESCRIPTORS","a","$getOwnPropertyDescriptor","O","P","toIndexedObject","toPropertyKey","IE8_DOM_DEFINE","createPropertyDescriptor","propertyIsEnumerableModule","f","$defineProperty","Attributes","anObject","object","definePropertyModule","functionToString","inspectSource","set","WeakMap","test","keys","OBJECT_ALREADY_INITIALIZED","NATIVE_WEAK_MAP","state","wmget","wmhas","wmset","metadata","facade","STATE","sharedKey","hiddenKeys","objectHas","createNonEnumerableProperty","enforce","getterFor","TYPE","type","FunctionPrototype","prototype","getDescriptor","PROPER","CONFIGURABLE","CONFIGURABLE_FUNCTION_NAME","require$$0","getInternalState","InternalStateModule","enforceInternalState","TEMPLATE","options","unsafe","simple","noTargetGet","replace","source","join","ceil","floor","isNaN","min","toInteger","max","index","integer","createMethod","IS_INCLUDES","$this","el","fromIndex","toLength","toAbsoluteIndex","includes","indexOf","names","i","enumBugKeys","concat","getOwnPropertyNames","internalObjectKeys","getOwnPropertyNamesModule","getOwnPropertySymbolsModule","target","ownKeys","getOwnPropertyDescriptorModule","replacement","isForced","feature","detection","data","normalize","POLYFILL","NATIVE","string","toLowerCase","targetProperty","sourceProperty","TARGET","GLOBAL","STATIC","stat","forced","copyConstructorProperties","redefine","Array","isArray","TO_STRING_TAG","CORRECT_ARGUMENTS","classofRaw","TO_STRING_TAG_SUPPORT","tag","tryGet","callee","empty","construct","constructorRegExp","INCORRECT_TO_STRING","isConstructorModern","called","SPECIES","originalArray","C","constructor","isConstructor","IS_MAP","IS_FILTER","IS_SOME","IS_EVERY","IS_FIND_INDEX","IS_FILTER_REJECT","NO_HOLES","callbackfn","that","specificCreate","boundFunction","b","c","apply","bind","create","arraySpeciesCreate","forEach","map","filter","some","every","find","findIndex","filterReject","METHOD_NAME","array","foo","Boolean","$map","proto","arrayMethodHasSpeciesSupport","IS_RIGHT","argumentsLength","memo","left","right","$reduce","arrayMethodIsStrict","IS_NODE","CHROME_VERSION","reduce","$filter","Cluster","markers","position","google","maps","LatLng","_position","bounds","marker","extend","getPosition","LatLngBounds","getCenter","m","getVisible","setMap","filterMarkersToPaddedViewport","mapCanvasProjection","viewportPadding","extendedMapBounds","extendBoundsToPaddedViewport","getBounds","contains","projection","pixels","latLngBoundsToPixelBounds","northEast","southWest","extendedPixelBounds","extendPixelBounds","pixelBoundsToLatLngBounds","distanceBetweenPoints","p1","p2","dLat","lat","PI","dLon","lng","sin","cos","atan2","sqrt","fromLatLngToDivPixel","getNorthEast","getSouthWest","x","y","fromDivPixelToLatLng","AbstractAlgorithm","maxZoom","noop","AbstractViewportAlgorithm","_a","getZoom","cluster","CSSRuleList","CSSStyleDeclaration","CSSValueList","ClientRectList","DOMRectList","DOMStringList","DOMTokenList","DataTransferItemList","FileList","HTMLAllCollection","HTMLCollection","HTMLFormElement","HTMLSelectElement","MediaList","MimeTypeArray","NamedNodeMap","NodeList","PaintRequestList","Plugin","PluginArray","SVGLengthList","SVGNumberList","SVGPathSegList","SVGPointList","SVGStringList","SVGTransformList","SourceBufferList","StyleSheetList","TextTrackCueList","TextTrackList","TouchList","classList","documentCreateElement","DOMTokenListPrototype","$forEach","handlePrototype","CollectionPrototype","COLLECTION_NAME","DOMIterables","toJSON","URL","GridAlgorithm","maxDistance","gridSize","clusters","_this2","addToClosestCluster","candidate","distance","NoopAlgorithm","earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","point","coordinates","properties","Error","isNumber","geom","feat","bbox","geometry","featureCollection","features","fc","radiansToLength","units","factor","degreesToRadians","convertLength","originalUnit","finalUnit","lengthToRadians","num","clone","geojson","cloneFeature","cloned","cloneFeatureCollection","cloneGeometry","cloneProperties","item","geometries","g","deepSlice","coords","coord","coordEach","callback","excludeWrapCoord","j","k","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordAll","len","ks","d","prs","v","vlen","kmpp","init","count","Infinity","dist","old","vsum","sum","h","ksj","_j3","cj","_i2","KmeansAlgorithm","numberOfClusters","points","round","mutate","initialCentroids","skmeansResult","skmeans","centroids","idx","featureEach","clusterId","idxs","centroid","clustersKmeans","$assign","assign","A","B","alphabet","chr","objectKeys","T","S","getCoord","from","to","coordinates1","coordinates2","lat1","lat2","pow","DBSCAN","dataset","epsilon","minPts","distanceFunction","_euclideanDistance","noise","_visited","_assigned","_datasetLength","_init","run","pointId","neighbors","_regionQuery","_addToCluster","_expandCluster","pointId2","neighbors2","_mergeArrays","p","q","exports","KMEANS","assignments","randomCentroid","change","centroidId","mean","maxDim","dim","getClusters","maxId","closestCentroid","argmin","Number","MAX_VALUE","arg","diff","PriorityQueue","elements","priorities","sorting","_queue","_priorities","_sorting","insert","ele","priority","indexToInsert","priority2","_insertAt","remove","splice","getElements","getElementPriority","getPriorities","getElementsWithPriorities","OPTICS","_reachability","_processed","_coreDistance","_orderedList","priorityQueue","_distanceToCore","_updateQueue","getReachabilityPlot","reachabilityPlot","queue","newReachableDistance","queueElements","coreDistCand","require$$1","require$$2","require$$3","DEFAULT_INTERNAL_DBSCAN_OPTION","minPoints","DBScanAlgorithm","projectedPoint","fromLatLngToContainerPixel","grouped","dbscan","clustering","clusteredIds","clusterIds","clusterPoint","noiseId","noisePoint","clustersDbscan","sortKD","ids","nodeSize","depth","select","inc","n","z","log","s","exp","sd","t","swapItem","swap","arr","tmp","sqDist","ax","ay","bx","by","dx","dy","defaultGetX","defaultGetY","KDBush","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","sort","range","minX","minY","maxX","maxY","stack","axis","pop","nextAxis","within","r","qx","qy","r2","defaultOptions","minZoom","radius","extent","generateId","props","fround","Float32Array","Supercluster","trees","load","console","time","timerId","createPointCluster","timeEnd","now","Date","_cluster","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","tree","_limitZoom","lngX","latY","numPoints","getClusterJSON","getChildren","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","origin","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","_addTileFeatures","getClusterExpansionZoom","expansionZoom","cluster_id","skipped","child","point_count","isCluster","tags","px","py","getClusterProperties","neighborIds","numPointsOrigin","neighborId","wx","wy","clusterProperties","_map","numPoints2","createCluster","original","yLat","abbrev","point_count_abbreviated","y2","atan","dest","src","equal","Map","size","entries","Set","ArrayBuffer","isView","RegExp","flags","SuperClusterAlgorithm","superCluster","SuperCluster","_this","west","south","east","north","transformCluster","leaf","$indexOf","nativeIndexOf","NEGATIVE_ZERO","STRICT_METHOD","searchElement","propertyKey","HAS_SPECIES_SUPPORT","MAX_SAFE_INTEGER","MAXIMUM_ALLOWED_LENGTH_EXCEEDED","start","deleteCount","insertCount","actualDeleteCount","actualStart","createProperty","activeXDocument","setPrototypeOf","setter","CORRECT_SETTER","aPossiblePrototype","__proto__","dummy","Wrapper","NewTarget","NewTargetPrototype","defineProperties","Properties","IE_PROTO","EmptyConstructor","scriptTag","content","LT","NullProtoObjectViaActiveX","write","close","temp","parentWindow","NullProtoObject","ActiveXObject","iframeDocument","iframe","domain","style","display","html","appendChild","contentWindow","open","F","whitespace","ltrim","rtrim","end","trim","NUMBER","NativeNumber","NumberPrototype","BROKEN_CLASSOF","toNumber","first","third","radix","maxCode","digits","code","charCodeAt","NaN","parseInt","NumberWrapper","inheritIfRequired","ClusterStats","clusterMarkerCounts","clusterMarkerSum","DefaultRenderer","stats","color","svg","btoa","Marker","icon","url","scaledSize","Size","label","text","fontSize","zIndex","MAX_ZINDEX","MarkerClustererEvents","OverlayViewSafe","type1","type2","property","OverlayView","defaultOnClusterClickHandler","_","fitBounds","MarkerClusterer","algorithm","renderer","onClusterClick","noDraw","render","addMarker","removed","_this3","removeMarker","_this4","getMap","getProjection","event","trigger","CLUSTERING_BEGIN","calculate","reset","renderClusters","CLUSTERING_END","idleListener","addListener","removeListener","delete","_this5","CLUSTER_CLICK"],"mappings":"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"}